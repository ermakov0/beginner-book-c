\documentclass[myc.tex]{subfiles}

\begin{document}
\chapter{Директивы препроцессора}
\label{ch:preprocessor}

Опасность макросов:


define SUM(x, y) x + y


+скобки всегда

+ do {} while(0)


if (0) SUM(1, 2);


и вообще не писать, а после есть inline-функции со 99 стандарта.


%> Совет 2. Используйте оператор #define чаще. КАК МОЖНО ЧАЩЕ.

Страуструп в 90х годах написал: 
"Первое правило о макросах (define в том числе): не используйте их, если вы не обязаны этого делать.... Механизмы const, inline, template и namespace создавались в качестве альтернативы традиционному использованию препроцессора"

%Мейерс того же мнения:
%"предпочитайте const, enum и inline использованию #define"

Их аргументы более убедительны, чем у Вогела. Такие дела.




Из стандарта 99:
\begin{lstlisting}
#define max(a, b) ((a) > (b) ? (a) : (b))
\end{lstlisting}







\section{assert}
%TODO ref

(C99)

Если выражение, переданное макросу, равно нулю, то макрос выводит сообщение и аварийно завершает программу.


\begin{lstlisting}
#include <stdio.h>

//#define NDEBUG
#include <assert.h>

int main() {
    assert(4 > 5);
    puts("all ok");
}
\end{lstlisting}

Результат выполнения программы:
\begin{verbatim}
7: main: Assertion `4 > 5' failed.
\end{verbatim} 

Если расскомментировать определение NDEBUG в 3 строке, то макрос assert исчезнет из кода.

\begin{verbatim}
all ok
\end{verbatim} 


С использование ассерта не должна строиться логика программы. Но нужен только для дополнительных проверок во время написания и тестирования программы. В релизной версии программы он должен быть отключён.






\vfill
\subsection*{Контрольные вопросы}
\begin{enumerate}
\item 55
\end{enumerate}
\end{document}
